/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from 'three';
import { Suspense, useEffect, useMemo, useRef } from 'react';
import { useGLTF, useAnimations } from '@react-three/drei';
import type { GLTF } from 'three/examples/jsm/Addons.js';
import { useGame } from 'ecctrl';
import type { ThreeElements } from '@react-three/fiber';

type GLTFResult = GLTF & {
  nodes: {
    Alpha_Joints: THREE.SkinnedMesh;
    Alpha_Surface: THREE.SkinnedMesh;
    mixamorigHips: THREE.Bone;
  };
  materials: {
    Alpha_Joints_MAT: THREE.MeshPhysicalMaterial;
    Alpha_Body_MAT: THREE.MeshPhysicalMaterial;
  };
};

type Props = ThreeElements['group'];

export function Model(props: Props) {
  const group = useRef<THREE.Group>(null!);
  const { nodes, materials, animations } = useGLTF(
    '/y-bot.glb'
  ) as unknown as GLTFResult;
  const { actions } = useAnimations(animations, group);

  /**
   * animation setup
   */

  const curAnimation = useGame((state) => state.curAnimation);
  const resetAnimation = useGame((state) => state.reset);
  const initializeAnimationSet = useGame(
    (state) => state.initializeAnimationSet
  );

  const animationSet = useMemo(() => {
    return {
      idle: 'idle',
      walk: 'walking',
      run: 'running',
      jump: 'jump',
    };
  }, []);

  useEffect(() => {
    initializeAnimationSet(animationSet);
    // console.log(curAnimation, animationSet);
  }, [animationSet, initializeAnimationSet]);

  useEffect(() => {
    //play animation
    const action = actions[curAnimation ? curAnimation : animationSet.idle];
    if (!action) return;

    console.log(action);

    if (curAnimation === animationSet.jump) {
      action.reset().fadeIn(0.2).setLoop(THREE.LoopOnce, 0).play();
      action.clampWhenFinished = true;
    } else {
      action.reset().fadeIn(0.2).play();
    }

    action.getMixer().addEventListener('finished', () => resetAnimation());

    return () => {
      //fade out previous action
      action.fadeOut(0.2);

      action.getMixer().removeEventListener('finished', () => resetAnimation());

      //@ts-expect-error mixer
      action._mixer._listeners = [];
    };
  }, [curAnimation, actions, animationSet, resetAnimation]);

  return (
    <Suspense fallback={<capsuleGeometry args={[0.3, 0.7]} />}>
      {/* Head collider */}
      {/* <BallCollider args={[0.3]} position={[0, 0.45, 0]} /> */}
      <group ref={group} {...props} dispose={null}>
        <group name='Scene'>
          <group
            name='Armature'
            rotation={[Math.PI / 2, 0, 0]}
            scale={0.01}
            // position={[0, 0, 0]}
            position-y={-0.95}
          >
            <skinnedMesh
              name='Alpha_Joints'
              geometry={nodes.Alpha_Joints.geometry}
              material={materials.Alpha_Joints_MAT}
              skeleton={nodes.Alpha_Joints.skeleton}
            />
            <skinnedMesh
              name='Alpha_Surface'
              geometry={nodes.Alpha_Surface.geometry}
              material={materials.Alpha_Body_MAT}
              skeleton={nodes.Alpha_Surface.skeleton}
            />
            <primitive object={nodes.mixamorigHips} />
          </group>
        </group>
      </group>
    </Suspense>
  );
}

useGLTF.preload('/y-bot.glb');
