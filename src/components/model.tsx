/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from 'three';
import { Suspense, useEffect, useMemo, useRef } from 'react';
import { useGLTF, useAnimations } from '@react-three/drei';
import type { GLTF } from 'three/examples/jsm/Addons.js';
import { useGame } from 'ecctrl';
import type { ThreeElements } from '@react-three/fiber';

type GLTFResult = GLTF & {
  nodes: {
    Alpha_Joints: THREE.SkinnedMesh;
    Alpha_Surface: THREE.SkinnedMesh;
    mixamorigHips: THREE.Bone;
  };
  materials: {
    Alpha_Joints_MAT: THREE.MeshPhysicalMaterial;
    Alpha_Body_MAT: THREE.MeshPhysicalMaterial;
  };
};

type Props = ThreeElements['group'];

export function Model(props: Props) {
  const group = useRef<THREE.Group>(null!);
  const { nodes, materials, animations } = useGLTF(
    '/y-bot_fixed.glb'
  ) as unknown as GLTFResult;
  const { actions } = useAnimations(animations, group);

  /**
   * animation setup
   */
  const curAnimation = useGame((state) => state.curAnimation);
  const resetAnimation = useGame((state) => state.reset);
  const initializeAnimationSet = useGame(
    (state) => state.initializeAnimationSet
  );

  const animationSet = useMemo(() => {
    return {
      idle: 'idle',
      walk: 'walking',
      run: 'running',
      jump: 'jump_up', //jump start
      jumpIdle: 'jump_idle', //jump in air
      jumpLand: 'jump_land', // jump landing
      fall: 'falling',
    };
  }, []);

  useEffect(() => {
    initializeAnimationSet(animationSet);
  }, []);

  useEffect(() => {
    //play animation
    const key = curAnimation ?? animationSet.idle;
    const action = key ? actions[key] : null;

    if (!action) return;
    if (
      curAnimation === animationSet.jump ||
      curAnimation === animationSet.jumpLand
    ) {
      action.reset().fadeIn(0.2).setLoop(THREE.LoopOnce, 0).play();
      action.clampWhenFinished = true;
    } else {
      action.reset().fadeIn(0.2).play();
    }

    action.getMixer().addEventListener('finished', () => resetAnimation());

    return () => {
      //fade out previous action
      action.fadeOut(0.2);

      action.getMixer().removeEventListener('finished', () => resetAnimation());

      //@ts-expect-error mixer
      action._mixer._listeners = [];
    };
  }, [curAnimation]);

  return (
    <Suspense fallback={<capsuleGeometry args={[0.3, 0.7]} />}>
      <group
        ref={group}
        {...props}
        dispose={null}
        userData={{ camExcludeCollision: true }}
        name='Armature'
        rotation={[Math.PI / 2, 0, 0]}
        scale={0.01}
        position={[0, 0, 0]}
        position-y={-0.95}
      >
        <skinnedMesh
          name='Alpha_Joints'
          geometry={nodes.Alpha_Joints.geometry}
          material={materials.Alpha_Joints_MAT}
          skeleton={nodes.Alpha_Joints.skeleton}
        />
        <skinnedMesh
          name='Alpha_Surface'
          geometry={nodes.Alpha_Surface.geometry}
          material={materials.Alpha_Body_MAT}
          skeleton={nodes.Alpha_Surface.skeleton}
        />
        <primitive object={nodes.mixamorigHips} />
      </group>
    </Suspense>
  );
}

useGLTF.preload('/y-bot_fixed.glb');
